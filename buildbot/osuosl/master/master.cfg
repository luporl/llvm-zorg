# -*- python -*-
# ex: set syntax=python:
from importlib import reload

# Extend paths to allow loading zorg and config modules.
import os, sys
# All the configuration files are under the directory
# where master.cfg file is.
cfg_path = os.path.abspath(os.path.dirname(__file__))
if cfg_path not in sys.path:
  sys.path.append(cfg_path)
# Zorg is 3 levels up.
path = os.path.abspath(
         os.path.join(cfg_path, '..', '..', '..')
       )
if path not in sys.path:
  sys.path.append(path)

##print(">>> sys.path={}}".format(sys.path)) # TODO: Remove this later.

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}
c['buildbotNetUsageData'] = None

import config
reload(config)

####### Workers

c['workers'] = config.workers.get_all()

c['protocols'] = {'pb': {'port': 9011}}

####### CHANGESOURCES

##from buildbot.changes.pb import PBChangeSource
from zorg.buildbot.changes.llvmgitpoller import LLVMPoller
from zorg.buildbot.process import buildrequest
reload(buildrequest)

from buildbot.plugins import changes

c['change_source'] = []
# TODO: Do we want to support a push mode for the changes? Probably not.
#c['change_source'].append(PBChangeSource())
c['change_source'].append(
    LLVMPoller(repourl='https://github.com/llvm/llvm-project.git',
               workdir='gitpoller-workdir',
               pollinterval=120))
c['change_source'].append(
    changes.GitPoller(repourl='https://github.com/llvm/llvm-lnt.git',
                      project='lnt',
                      branch='master',
                      workdir='gitpoller-llvm-lnt',
                      pollinterval=60*60))

c['collapseRequests'] = buildrequest.collapseRequests

####### BUILDERS

from buildbot.plugins import util

def print_req(req):
  print("LLL:   bsid", req.bsid, "builderid", req.builderid, "buildername", req.buildername)
  print("LLL:   id", req.id, "priority", req.priority, "reason", req.reason)
  print("LLL:   submittedAt", req.submittedAt, "waitedFor", req.waitedFor)
  print("LLL:   properties", req.properties)

def next_llbuild(builder, reqs):
  # debug logs
  print("LLL: builder", builder, "building", builder.building)
  print("LLL: reqs:")
  for req in reqs:
    print_req(req)

  if bool(builder.building):
    print("LLL: already building")
    return False
  else:
    req = min(reqs, key=lambda req: req.submittedAt)
    print("LLL: min req:")
    print_req(req)
    return req

builders = []
for b in config.builders.all:
  nextBuild = None
  if b['name'].startswith("llbuild"):
    print("LLL: Using nextBuild for builder", b['name'])
    nextBuild = next_llbuild
  builders.append(util.BuilderConfig(**b, nextBuild=nextBuild))
c['builders'] = builders

for rb in config.release_builders.all:
    # Make sure a release builder has the "release" tag.
    tags = rb.get('tags', [])
    if 'release' not in tags:
        rb['tags'] = tags + ['release']
    builders.append(util.BuilderConfig(**rb))

####### SCHEDULERS

c['schedulers'] = config.schedulers.getMainBranchSchedulers(
                                             builders)
c['schedulers'].extend(config.schedulers.getLntSchedulers())
c['schedulers'].extend(config.schedulers.getReleaseBranchSchedulers(
                                             builders,
                                             treeStableTimer=5*60))
c['schedulers'].extend(config.schedulers.getForceSchedulers(
                                             builders))

####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.

# Configure MailNotifier, IRC, buildbot.reporters.github.GitHubStatusPush, buildbot.reporters.github.GitHubCommentPush
c['services'] = config.status.getReporters()

####### PROJECT IDENTITY

c['title'] = "linaro_llvm_luporl"
c['titleURL'] = "http://localhost:8011/"
c['buildbotURL'] = "http://localhost:8011/"

# minimalistic config to activate new web UI
c['www'] = dict(port=8011,
                plugins=dict(waterfall_view={}, console_view={}, grid_view={}), # TODO: badges
                default_page='console',
                auth=config.auth.getAuth(),
                authz=config.auth.getAuthz(),
                #logRotateLength=
                #maxRotatedFiles=
                #versions=
            )

####### DB URL

c['db'] = { 'db_url' : 'sqlite:///state.sqlite' }

####### RESOURCE USAGE

from datetime import timedelta

# TODO: Figure out the "changeHorizon" value for our usage.
#c["changeHorizon"] = 300

# configure a janitor which will delete all logs older than one month,
# and will run on sundays at noon
# TODO: Recheck the setting for the production bot.
c['configurators'] = [util.JanitorConfigurator(
    logHorizon=timedelta(weeks=4), # Roughly once a month.
    hour=12,
    dayOfWeek=6
)]
